{
  "metadata": {
    "version": "1.0",
    "created_at": "2026-02-17T20:20:25.131644+00:00",
    "updated_at": "2026-02-17T22:29:21.580115+00:00"
  },
  "stories": [
    {
      "id": "US-001",
      "title": "Add fixed device sample rate constant to @iris/domain",
      "feature_area": "WA1: Domain Constants",
      "priority": "Must",
      "role": "developer",
      "want": "a DEVICE_SAMPLE_RATE_HZ constant exported from @iris/domain",
      "benefit": "all mobile app modules reference a single authoritative 215 Hz value instead of scattered literals",
      "acceptance_criteria": [
        {
          "id": "AC1",
          "given": "the developer imports from @iris/domain",
          "when": "referencing the sample rate constant",
          "then": "DEVICE_SAMPLE_RATE_HZ equals 215 and is typed as a number"
        },
        {
          "id": "AC2",
          "given": "the developer imports from @iris/domain",
          "when": "referencing the chart display rate",
          "then": "CHART_DISPLAY_RATE_HZ equals 40 and is typed as a number"
        },
        {
          "id": "AC3",
          "given": "packages/domain/src/index.ts barrel file",
          "when": "the file is inspected",
          "then": "both DEVICE_SAMPLE_RATE_HZ and CHART_DISPLAY_RATE_HZ are re-exported"
        },
        {
          "id": "AC4",
          "given": "npm run type-check:all is executed",
          "when": "checking packages/domain",
          "then": "zero new TypeScript strict-mode errors are reported"
        },
        {
          "id": "AC5",
          "given": "the constant names are reviewed",
          "when": "checking naming convention",
          "then": "they follow UPPER_SNAKE_CASE as required by project style"
        }
      ],
      "notes": "",
      "dependencies": [],
      "status": "Ready",
      "created_at": "2026-02-17T20:20:39.996237+00:00",
      "updated_at": "2026-02-17T20:22:44.614109+00:00",
      "created_by": "po",
      "history": [
        {
          "action": "created",
          "by": "po",
          "at": "2026-02-17T20:20:39.996237+00:00"
        },
        {
          "action": "status_change",
          "by": "po",
          "from": "Draft",
          "to": "Ready",
          "at": "2026-02-17T20:22:17.422287+00:00"
        },
        {
          "action": "edited",
          "by": "po",
          "changes": [
            "acceptance_criteria"
          ],
          "at": "2026-02-17T20:22:44.614109+00:00"
        }
      ]
    },
    {
      "id": "US-002",
      "title": "Fix BluetoothContext default stream rate to 215 Hz for real-device path",
      "feature_area": "WA2: BluetoothContext Rate Fix",
      "priority": "Must",
      "role": "researcher",
      "want": "the app to use 215 Hz as the default stream sample rate when connected to the real device",
      "benefit": "CSV timestamps and recording metadata reflect the actual ESP32 hardware rate, ensuring clinical data accuracy",
      "acceptance_criteria": [
        {
          "id": "AC1",
          "given": "the mobile app initialises BluetoothContext",
          "when": "no explicit configureStream call has been made",
          "then": "streamConfig.rate is 215 (DEVICE_SAMPLE_RATE_HZ), not 100"
        },
        {
          "id": "AC2",
          "given": "the developer reads BluetoothContext source",
          "when": "locating rate references in startStream() and stopStream()",
          "then": "they reference DEVICE_SAMPLE_RATE_HZ constant, not a numeric literal"
        },
        {
          "id": "AC3",
          "given": "the app is running in simulation mode without a BT device",
          "when": "streaming is started",
          "then": "simulation mode uses its own independent 50 Hz rate unchanged"
        },
        {
          "id": "AC4",
          "given": "existing consumers of BluetoothContext",
          "when": "the change is applied",
          "then": "all public API methods (connect, disconnect, configureStream, etc.) retain the same signatures"
        },
        {
          "id": "AC5",
          "given": "npm run type-check:all is executed",
          "when": "checking BluetoothContext.tsx",
          "then": "zero new TypeScript strict-mode errors are reported"
        }
      ],
      "notes": "",
      "dependencies": [
        "US-001"
      ],
      "status": "Ready",
      "created_at": "2026-02-17T20:20:50.798903+00:00",
      "updated_at": "2026-02-17T20:22:54.307960+00:00",
      "created_by": "po",
      "history": [
        {
          "action": "created",
          "by": "po",
          "at": "2026-02-17T20:20:50.798903+00:00"
        },
        {
          "action": "status_change",
          "by": "po",
          "from": "Draft",
          "to": "Ready",
          "at": "2026-02-17T20:22:17.559871+00:00"
        },
        {
          "action": "edited",
          "by": "po",
          "changes": [
            "acceptance_criteria"
          ],
          "at": "2026-02-17T20:22:54.307960+00:00"
        }
      ]
    },
    {
      "id": "US-003",
      "title": "Make StreamConfigScreen sampling rate read-only (215 Hz fixed)",
      "feature_area": "WA3: StreamConfigScreen Simplification",
      "priority": "Must",
      "role": "researcher",
      "want": "the stream configuration screen to show 215 Hz as a non-editable fixed value",
      "benefit": "users cannot accidentally override the hardware rate, preventing misconfigured recordings",
      "acceptance_criteria": [
        {
          "id": "AC1",
          "given": "a user opens StreamConfigScreen",
          "when": "the screen renders",
          "then": "the sample rate field shows 215 Hz and cannot be edited (picker removed or input is read-only)"
        },
        {
          "id": "AC2",
          "given": "a user opens StreamConfigScreen",
          "when": "interacting with the data type selector",
          "then": "it remains fully functional and can be changed normally"
        },
        {
          "id": "AC3",
          "given": "the summary section of StreamConfigScreen",
          "when": "rendered",
          "then": "it displays 215 Hz as the configured rate"
        },
        {
          "id": "AC4",
          "given": "any user interaction on the rate field",
          "when": "attempted",
          "then": "no change is possible â€” the field is non-interactive"
        },
        {
          "id": "AC5",
          "given": "npm run type-check:all is executed",
          "when": "checking StreamConfigScreen.tsx",
          "then": "zero new TypeScript strict-mode errors are reported"
        }
      ],
      "notes": "",
      "dependencies": [
        "US-001"
      ],
      "status": "Ready",
      "created_at": "2026-02-17T20:20:58.648276+00:00",
      "updated_at": "2026-02-17T20:23:01.659079+00:00",
      "created_by": "po",
      "history": [
        {
          "action": "created",
          "by": "po",
          "at": "2026-02-17T20:20:58.648276+00:00"
        },
        {
          "action": "status_change",
          "by": "po",
          "from": "Draft",
          "to": "Ready",
          "at": "2026-02-17T20:22:17.697247+00:00"
        },
        {
          "action": "edited",
          "by": "po",
          "changes": [
            "acceptance_criteria"
          ],
          "at": "2026-02-17T20:23:01.659079+00:00"
        }
      ]
    },
    {
      "id": "US-004",
      "title": "Fix CaptureScreen CSV timestamp interpolation to use 215 Hz constant",
      "feature_area": "WA4: CaptureScreen CSV & Recording Fix",
      "priority": "Must",
      "role": "researcher",
      "want": "recording CSV files to use correct 215 Hz inter-sample timestamps",
      "benefit": "the time axis in exported CSVs is clinically accurate, and blob-uploaded recordings contain valid signal data",
      "acceptance_criteria": [
        {
          "id": "AC1",
          "given": "a recording is captured from the real ESP32 device",
          "when": "createCSVContent() runs",
          "then": "inter-sample timestamps use DEVICE_SAMPLE_RATE_HZ (215 Hz) â€” interval = 1000/215 ms"
        },
        {
          "id": "AC2",
          "given": "the app is in simulation mode",
          "when": "createCSVContent() runs",
          "then": "inter-sample timestamps use 50 Hz â€” interval = 1000/50 ms"
        },
        {
          "id": "AC3",
          "given": "a real-device recording entity is created",
          "when": "NewRecordingData.sampleRate is set",
          "then": "it equals DEVICE_SAMPLE_RATE_HZ (215)"
        },
        {
          "id": "AC4",
          "given": "a simulation-mode recording entity is created",
          "when": "NewRecordingData.sampleRate is set",
          "then": "it equals 50"
        },
        {
          "id": "AC5",
          "given": "an exported CSV file from a real-device session",
          "when": "opened in a spreadsheet",
          "then": "timestamp column increments by ~4.65 ms per row (1000/215)"
        },
        {
          "id": "AC6",
          "given": "npm run type-check:all is executed",
          "when": "checking CaptureScreen.tsx",
          "then": "zero new TypeScript strict-mode errors are reported"
        }
      ],
      "notes": "",
      "dependencies": [
        "US-001 US-002"
      ],
      "status": "Ready",
      "created_at": "2026-02-17T20:21:07.906699+00:00",
      "updated_at": "2026-02-17T20:23:10.378337+00:00",
      "created_by": "po",
      "history": [
        {
          "action": "created",
          "by": "po",
          "at": "2026-02-17T20:21:07.906699+00:00"
        },
        {
          "action": "status_change",
          "by": "po",
          "from": "Draft",
          "to": "Ready",
          "at": "2026-02-17T20:22:17.826901+00:00"
        },
        {
          "action": "edited",
          "by": "po",
          "changes": [
            "acceptance_criteria"
          ],
          "at": "2026-02-17T20:23:10.378337+00:00"
        }
      ]
    },
    {
      "id": "US-005",
      "title": "Refactor useStreamData hook: 4-second window, 40 Hz downsample, 1 Hz update cadence",
      "feature_area": "WA5: Chart Visualization Fix",
      "priority": "Must",
      "role": "researcher",
      "want": "the stream data hook to expose only the last 4 seconds of data downsampled to 40 Hz and refreshed at 1 Hz",
      "benefit": "the capture chart renders efficiently with predictable 160-point datasets and does not overwhelm the UI thread",
      "acceptance_criteria": [
        {
          "id": "AC1",
          "given": "streaming data arrives at 215 Hz",
          "when": "the hook processes packets",
          "then": "an internal buffer holds only the last 4 seconds (~860 raw samples)"
        },
        {
          "id": "AC2",
          "given": "the hook is queried for chart data",
          "when": "the caller reads the output array",
          "then": "it contains ~160 points (4s Ã— 40 Hz downsampled from 215 Hz buffer)"
        },
        {
          "id": "AC3",
          "given": "packets arrive continuously",
          "when": "one second elapses",
          "then": "the hook outputs updated chart data exactly once (1 Hz cadence)"
        },
        {
          "id": "AC4",
          "given": "the downsampling implementation",
          "when": "reviewed",
          "then": "it uses decimation or averaging without introducing visible aliasing artifacts"
        },
        {
          "id": "AC5",
          "given": "the hook implementation",
          "when": "reviewed",
          "then": "it imports DEVICE_SAMPLE_RATE_HZ and CHART_DISPLAY_RATE_HZ from @iris/domain â€” no magic numbers"
        },
        {
          "id": "AC6",
          "given": "npm run type-check:all is executed",
          "when": "checking useStreamData.ts",
          "then": "zero new TypeScript strict-mode errors are reported"
        }
      ],
      "notes": "",
      "dependencies": [
        "US-001"
      ],
      "status": "Ready",
      "created_at": "2026-02-17T20:21:17.700125+00:00",
      "updated_at": "2026-02-17T20:23:20.192522+00:00",
      "created_by": "po",
      "history": [
        {
          "action": "created",
          "by": "po",
          "at": "2026-02-17T20:21:17.700125+00:00"
        },
        {
          "action": "status_change",
          "by": "po",
          "from": "Draft",
          "to": "Ready",
          "at": "2026-02-17T20:22:17.958297+00:00"
        },
        {
          "action": "edited",
          "by": "po",
          "changes": [
            "acceptance_criteria"
          ],
          "at": "2026-02-17T20:23:20.192522+00:00"
        }
      ]
    },
    {
      "id": "US-006",
      "title": "Fix SEMGChart to render fixed 4-second viewport with no horizontal scroll",
      "feature_area": "WA5: Chart Visualization Fix",
      "priority": "Must",
      "role": "researcher",
      "want": "the real-time chart to display a fixed 4-second window without horizontal scrolling",
      "benefit": "the capture screen is less distracting during clinical data collection and avoids unnecessary GPU work",
      "acceptance_criteria": [
        {
          "id": "AC1",
          "given": "the SEMGChart component receives chart data",
          "when": "rendering",
          "then": "it renders at most 160 data points (the downsampled output from useStreamData)"
        },
        {
          "id": "AC2",
          "given": "the SEMGChart component layout",
          "when": "inspected",
          "then": "there is no horizontal ScrollView wrapping the chart element"
        },
        {
          "id": "AC3",
          "given": "the SEMGChart component",
          "when": "new data arrives",
          "then": "auto-scroll behavior is absent â€” the viewport does not scroll horizontally"
        },
        {
          "id": "AC4",
          "given": "the device screen size changes",
          "when": "SEMGChart renders",
          "then": "the chart fills the available screen width responsively"
        },
        {
          "id": "AC5",
          "given": "npm run type-check:all is executed",
          "when": "checking SEMGChart.tsx",
          "then": "zero new TypeScript strict-mode errors are reported"
        }
      ],
      "notes": "",
      "dependencies": [
        "US-005"
      ],
      "status": "Ready",
      "created_at": "2026-02-17T20:21:25.401497+00:00",
      "updated_at": "2026-02-17T20:23:27.120963+00:00",
      "created_by": "po",
      "history": [
        {
          "action": "created",
          "by": "po",
          "at": "2026-02-17T20:21:25.401497+00:00"
        },
        {
          "action": "status_change",
          "by": "po",
          "from": "Draft",
          "to": "Ready",
          "at": "2026-02-17T20:22:18.089468+00:00"
        },
        {
          "action": "edited",
          "by": "po",
          "changes": [
            "acceptance_criteria"
          ],
          "at": "2026-02-17T20:23:27.120963+00:00"
        }
      ]
    },
    {
      "id": "US-007",
      "title": "Wire CaptureScreen chart parameters to corrected 215 Hz stream and 1 Hz refresh",
      "feature_area": "WA5: Chart Visualization Fix",
      "priority": "Must",
      "role": "researcher",
      "want": "the CaptureScreen to pass the correct sample rate and chart update throttle to useStreamData and SEMGChart",
      "benefit": "the capture screen chart reflects the real 215 Hz signal cadence and updates at the specified 1 Hz display rate",
      "acceptance_criteria": [
        {
          "id": "AC1",
          "given": "CaptureScreen calls useStreamData",
          "when": "passing the sample rate parameter",
          "then": "it passes DEVICE_SAMPLE_RATE_HZ (215), not streamConfig.rate"
        },
        {
          "id": "AC2",
          "given": "chart state update logic in CaptureScreen",
          "when": "packets arrive at 215 Hz",
          "then": "chart state is updated at most once per second (throttled to 1 Hz)"
        },
        {
          "id": "AC3",
          "given": "a live stream is active",
          "when": "observing the SEMGChart visually",
          "then": "chart shows only the last ~4 seconds of signal data (the sliding window)"
        },
        {
          "id": "AC4",
          "given": "npm run type-check:all is executed",
          "when": "checking CaptureScreen.tsx chart-related changes",
          "then": "zero new TypeScript strict-mode errors are reported"
        }
      ],
      "notes": "",
      "dependencies": [
        "US-004 US-005 US-006"
      ],
      "status": "Ready",
      "created_at": "2026-02-17T20:21:33.830124+00:00",
      "updated_at": "2026-02-17T20:23:33.844312+00:00",
      "created_by": "po",
      "history": [
        {
          "action": "created",
          "by": "po",
          "at": "2026-02-17T20:21:33.830124+00:00"
        },
        {
          "action": "status_change",
          "by": "po",
          "from": "Draft",
          "to": "Ready",
          "at": "2026-02-17T20:22:18.227357+00:00"
        },
        {
          "action": "edited",
          "by": "po",
          "changes": [
            "acceptance_criteria"
          ],
          "at": "2026-02-17T20:23:33.844312+00:00"
        }
      ]
    },
    {
      "id": "US-008",
      "title": "Add jszip (or equivalent) dependency to mobile app for ZIP export",
      "feature_area": "WA6: ZIP Export from History",
      "priority": "Must",
      "role": "developer",
      "want": "a ZIP archive library available in the mobile app bundle",
      "benefit": "the export function can produce ZIP archives compatible with Expo's file system and sharing APIs",
      "acceptance_criteria": [
        {
          "id": "AC1",
          "given": "apps/mobile/package.json is inspected",
          "when": "checking production dependencies",
          "then": "jszip (or fflate) is listed as a dependency with a compatible version"
        },
        {
          "id": "AC2",
          "given": "the chosen library",
          "when": "evaluated against Expo 52 compatibility matrix",
          "then": "it does not require native module linking or eject"
        },
        {
          "id": "AC3",
          "given": "the chosen library",
          "when": "TypeScript types are checked",
          "then": "@types/jszip or built-in types are available with no type errors"
        },
        {
          "id": "AC4",
          "given": "npm install is run in apps/mobile",
          "when": "it completes",
          "then": "no peer-dependency conflicts are reported"
        }
      ],
      "notes": "",
      "dependencies": [],
      "status": "Ready",
      "created_at": "2026-02-17T20:21:41.592645+00:00",
      "updated_at": "2026-02-17T20:23:42.196164+00:00",
      "created_by": "po",
      "history": [
        {
          "action": "created",
          "by": "po",
          "at": "2026-02-17T20:21:41.592645+00:00"
        },
        {
          "action": "status_change",
          "by": "po",
          "from": "Draft",
          "to": "Ready",
          "at": "2026-02-17T20:22:18.388402+00:00"
        },
        {
          "action": "edited",
          "by": "po",
          "changes": [
            "acceptance_criteria"
          ],
          "at": "2026-02-17T20:23:42.196164+00:00"
        }
      ]
    },
    {
      "id": "US-009",
      "title": "Implement exportSessionAsZip() in csvExport.ts",
      "feature_area": "WA6: ZIP Export from History",
      "priority": "Must",
      "role": "developer",
      "want": "a new exportSessionAsZip() function that produces a ZIP containing session.json and per-recording CSVs",
      "benefit": "history exports are structured, clinically meaningful artifacts that researchers can import into analysis tools",
      "acceptance_criteria": [
        {
          "id": "AC1",
          "given": "csvExport.ts is inspected",
          "when": "looking for the export API",
          "then": "exportSessionAsZip(session, recordings) is exported with the correct signature"
        },
        {
          "id": "AC2",
          "given": "exportSessionAsZip is called with a session and its recordings",
          "when": "the ZIP is opened",
          "then": "it contains a session.json with sessionId, volunteer, bodyStructure, laterality, startTime, duration, sampleRate (215), dataType, and recordings array with filenames"
        },
        {
          "id": "AC3",
          "given": "exportSessionAsZip is called with two recordings",
          "when": "the ZIP is opened",
          "then": "it contains recording_001.csv and recording_002.csv with actual signal data rows"
        },
        {
          "id": "AC4",
          "given": "recording CSV files exist on disk at recording.filePath",
          "when": "exportSessionAsZip runs",
          "then": "it reads them via expo-file-system â€” it does NOT regenerate data from memory"
        },
        {
          "id": "AC5",
          "given": "the ZIP file",
          "when": "presented via expo-sharing",
          "then": "it has MIME type application/zip and a .zip filename extension"
        },
        {
          "id": "AC6",
          "given": "npm run type-check:all is executed",
          "when": "checking csvExport.ts",
          "then": "zero new TypeScript strict-mode errors are reported"
        }
      ],
      "notes": "",
      "dependencies": [
        "US-008"
      ],
      "status": "Ready",
      "created_at": "2026-02-17T20:21:53.132286+00:00",
      "updated_at": "2026-02-17T20:23:52.698559+00:00",
      "created_by": "po",
      "history": [
        {
          "action": "created",
          "by": "po",
          "at": "2026-02-17T20:21:53.132286+00:00"
        },
        {
          "action": "status_change",
          "by": "po",
          "from": "Draft",
          "to": "Ready",
          "at": "2026-02-17T20:22:18.523032+00:00"
        },
        {
          "action": "edited",
          "by": "po",
          "changes": [
            "acceptance_criteria"
          ],
          "at": "2026-02-17T20:23:52.698559+00:00"
        }
      ]
    },
    {
      "id": "US-010",
      "title": "Wire HistoryScreen export to new ZIP export function",
      "feature_area": "WA6: ZIP Export from History",
      "priority": "Must",
      "role": "researcher",
      "want": "the history screen export action to produce a structured ZIP file instead of a single flat CSV",
      "benefit": "exported session data is immediately usable by researchers without manual reorganisation",
      "acceptance_criteria": [
        {
          "id": "AC1",
          "given": "the user taps export on a session in HistoryScreen",
          "when": "handleExportSession runs",
          "then": "it calls exportSessionAsZip() instead of the legacy exportSessionData()"
        },
        {
          "id": "AC2",
          "given": "handleExportSession is executed",
          "when": "passing data to the zip function",
          "then": "it provides the recording entities whose filePath fields reference the on-disk CSV files"
        },
        {
          "id": "AC3",
          "given": "the share sheet is presented",
          "when": "the user sees the share prompt",
          "then": "the shared file has MIME type application/zip and a .zip filename"
        },
        {
          "id": "AC4",
          "given": "csvExport.ts is inspected",
          "when": "reviewing exports",
          "then": "the legacy exportSessionData() function is removed or clearly deprecated if still used for another purpose"
        },
        {
          "id": "AC5",
          "given": "npm run type-check:all is executed",
          "when": "checking HistoryScreen.tsx",
          "then": "zero new TypeScript strict-mode errors are reported"
        }
      ],
      "notes": "",
      "dependencies": [
        "US-009"
      ],
      "status": "Ready",
      "created_at": "2026-02-17T20:22:02.199062+00:00",
      "updated_at": "2026-02-17T20:24:01.096834+00:00",
      "created_by": "po",
      "history": [
        {
          "action": "created",
          "by": "po",
          "at": "2026-02-17T20:22:02.199062+00:00"
        },
        {
          "action": "status_change",
          "by": "po",
          "from": "Draft",
          "to": "Ready",
          "at": "2026-02-17T20:22:18.662690+00:00"
        },
        {
          "action": "edited",
          "by": "po",
          "changes": [
            "acceptance_criteria"
          ],
          "at": "2026-02-17T20:24:01.096834+00:00"
        }
      ]
    },
    {
      "id": "US-011",
      "title": "Verify TypeScript strict mode compliance across all modified files",
      "feature_area": "WA7: Type Safety & Cleanup",
      "priority": "Must",
      "role": "developer",
      "want": "a clean npm run type-check:all output with zero new type errors introduced by this sprint",
      "benefit": "the codebase remains type-safe and no silent runtime type bugs are introduced alongside the bug fixes",
      "acceptance_criteria": [
        {
          "id": "AC1",
          "given": "npm run type-check:all is run after all changes",
          "when": "checking the 8 modified files",
          "then": "zero new TypeScript errors appear in Stream.ts, BluetoothContext.tsx, StreamConfigScreen.tsx, CaptureScreen.tsx, useStreamData.ts, SEMGChart.tsx, csvExport.ts, HistoryScreen.tsx"
        },
        {
          "id": "AC2",
          "given": "any modified file is inspected",
          "when": "reviewing type annotations",
          "then": "no any type is introduced â€” all types are explicit"
        },
        {
          "id": "AC3",
          "given": "csvExport.ts is inspected",
          "when": "looking for legacy code",
          "then": "exportSessionData() is deleted or has a clear deprecation notice if retained for a distinct use case"
        },
        {
          "id": "AC4",
          "given": "@iris/domain barrel (index.ts)",
          "when": "the exports are reviewed",
          "then": "DEVICE_SAMPLE_RATE_HZ and CHART_DISPLAY_RATE_HZ are correctly exported"
        },
        {
          "id": "AC5",
          "given": "any import statement in modified files",
          "when": "reviewed",
          "then": "it uses the @/ alias prefix as required by project CLAUDE.md, not relative paths"
        }
      ],
      "notes": "",
      "dependencies": [
        "US-001 US-002 US-003 US-004 US-005 US-006 US-007 US-008 US-009 US-010"
      ],
      "status": "Ready",
      "created_at": "2026-02-17T20:22:11.820022+00:00",
      "updated_at": "2026-02-17T20:24:11.776638+00:00",
      "created_by": "po",
      "history": [
        {
          "action": "created",
          "by": "po",
          "at": "2026-02-17T20:22:11.820022+00:00"
        },
        {
          "action": "status_change",
          "by": "po",
          "from": "Draft",
          "to": "Ready",
          "at": "2026-02-17T20:22:18.817262+00:00"
        },
        {
          "action": "edited",
          "by": "po",
          "changes": [
            "acceptance_criteria"
          ],
          "at": "2026-02-17T20:24:11.776638+00:00"
        }
      ]
    },
    {
      "id": "US-012",
      "title": "Add binary protocol constants to @iris/domain",
      "feature_area": "Binary Protocol Support",
      "priority": "Must",
      "role": "developer",
      "want": "a single source of truth for binary protocol constants (magic byte, message code, header size, samples per packet, total packet size)",
      "benefit": "all binary decoder code references named constants instead of magic numbers, and the TypeScript side mirrors StreamingProtocol.h on the ESP32",
      "acceptance_criteria": [
        {
          "id": "AC1",
          "given": "the developer imports from @iris/domain",
          "when": "referencing the binary magic byte",
          "then": "BINARY_PACKET_MAGIC equals 0xAA and is typed as a number constant"
        },
        {
          "id": "AC2",
          "given": "the developer imports from @iris/domain",
          "when": "referencing the binary message code",
          "then": "BINARY_PACKET_CODE equals 0x0D (13) and is typed as a number constant"
        },
        {
          "id": "AC3",
          "given": "the developer imports from @iris/domain",
          "when": "referencing header and packet sizes",
          "then": "BINARY_PACKET_HEADER_SIZE equals 8, BINARY_PACKET_SAMPLES_PER_PACKET equals 50, and BINARY_PACKET_TOTAL_SIZE equals 108"
        },
        {
          "id": "AC4",
          "given": "packages/domain/src/models/Stream.ts is inspected",
          "when": "checking for const declarations",
          "then": "all five binary protocol constants are declared and no any types are used"
        },
        {
          "id": "AC5",
          "given": "packages/domain/src/index.ts is inspected",
          "when": "checking barrel exports",
          "then": "all five binary protocol constants are re-exported"
        }
      ],
      "notes": "",
      "dependencies": [],
      "status": "In Review",
      "created_at": "2026-02-17T20:56:39.620557+00:00",
      "updated_at": "2026-02-17T21:13:00.604232+00:00",
      "created_by": "po",
      "history": [
        {
          "action": "created",
          "by": "po",
          "at": "2026-02-17T20:56:39.620557+00:00"
        },
        {
          "action": "status_change",
          "by": "po",
          "from": "Draft",
          "to": "Ready",
          "at": "2026-02-17T20:58:19.913924+00:00"
        },
        {
          "action": "edited",
          "by": "po",
          "changes": [
            "acceptance_criteria"
          ],
          "at": "2026-02-17T20:59:31.383846+00:00"
        },
        {
          "action": "status_change",
          "by": "dev",
          "from": "Ready",
          "to": "In Progress",
          "at": "2026-02-17T21:10:57.290399+00:00"
        },
        {
          "action": "status_change",
          "by": "dev",
          "from": "In Progress",
          "to": "In Review",
          "at": "2026-02-17T21:13:00.604232+00:00"
        }
      ]
    },
    {
      "id": "US-013",
      "title": "Implement decodeBinaryPacket() utility function",
      "feature_area": "Binary Protocol Support",
      "priority": "Must",
      "role": "developer",
      "want": "a pure function that parses a 108-byte binary sEMG packet from a Uint8Array into a StreamDataPacket",
      "benefit": "binary decoding logic is isolated, testable, and not entangled with BluetoothContext state management",
      "acceptance_criteria": [
        {
          "id": "AC1",
          "given": "apps/mobile/src/utils/binaryDecoder.ts is created",
          "when": "the file is inspected",
          "then": "it exports a decodeBinaryPacket function with signature: (buffer: Uint8Array, offset: number) => { packet: StreamDataPacket; bytesConsumed: number } | null"
        },
        {
          "id": "AC2",
          "given": "decodeBinaryPacket is called with a buffer where byte at offset is not 0xAA",
          "when": "the function executes",
          "then": "it returns null"
        },
        {
          "id": "AC3",
          "given": "decodeBinaryPacket is called with a buffer where byte at offset+1 is not 0x0D",
          "when": "the function executes",
          "then": "it returns null"
        },
        {
          "id": "AC4",
          "given": "decodeBinaryPacket is called with a valid 108-byte packet",
          "when": "the function executes",
          "then": "it returns a StreamDataPacket with correct timestamp (uint32 LE from bytes 2-5) and 50 int16 LE sample values"
        },
        {
          "id": "AC5",
          "given": "decodeBinaryPacket returns a result",
          "when": "bytesConsumed is inspected",
          "then": "it equals 108"
        },
        {
          "id": "AC6",
          "given": "tsc --noEmit is run on the mobile workspace",
          "when": "checking binaryDecoder.ts",
          "then": "zero strict-mode errors and no any types are present"
        }
      ],
      "notes": "",
      "dependencies": [
        "US-012"
      ],
      "status": "In Review",
      "created_at": "2026-02-17T20:56:50.148154+00:00",
      "updated_at": "2026-02-17T21:13:00.734927+00:00",
      "created_by": "po",
      "history": [
        {
          "action": "created",
          "by": "po",
          "at": "2026-02-17T20:56:50.149156+00:00"
        },
        {
          "action": "status_change",
          "by": "po",
          "from": "Draft",
          "to": "Ready",
          "at": "2026-02-17T20:58:20.035451+00:00"
        },
        {
          "action": "edited",
          "by": "po",
          "changes": [
            "acceptance_criteria"
          ],
          "at": "2026-02-17T20:59:31.477666+00:00"
        },
        {
          "action": "status_change",
          "by": "dev",
          "from": "Ready",
          "to": "In Progress",
          "at": "2026-02-17T21:10:57.436614+00:00"
        },
        {
          "action": "status_change",
          "by": "dev",
          "from": "In Progress",
          "to": "In Review",
          "at": "2026-02-17T21:13:00.734927+00:00"
        }
      ]
    },
    {
      "id": "US-014",
      "title": "Implement BinaryFrameAccumulator class for SPP packet framing",
      "feature_area": "Binary Protocol Support",
      "priority": "Must",
      "role": "developer",
      "want": "a class that accumulates incoming Bluetooth SPP byte chunks and yields complete 108-byte binary packets",
      "benefit": "partial packet fragments are held across onDataReceived callbacks until enough bytes arrive to form a complete packet, eliminating data loss from SPP fragmentation",
      "acceptance_criteria": [
        {
          "id": "AC1",
          "given": "apps/mobile/src/utils/binaryDecoder.ts is inspected",
          "when": "checking exports",
          "then": "it also exports a BinaryFrameAccumulator class with a feed(chunk: Uint8Array): StreamDataPacket[] method"
        },
        {
          "id": "AC2",
          "given": "a single complete 108-byte packet is passed to feed()",
          "when": "the method executes",
          "then": "it returns an array with exactly one decoded StreamDataPacket"
        },
        {
          "id": "AC3",
          "given": "a 50-byte fragment is passed to feed() followed by the remaining 58 bytes",
          "when": "both calls complete",
          "then": "the first call returns an empty array and the second returns one complete StreamDataPacket"
        },
        {
          "id": "AC4",
          "given": "two consecutive complete packets are passed in a single feed() call",
          "when": "the method executes",
          "then": "it returns an array with exactly two decoded StreamDataPacket objects"
        },
        {
          "id": "AC5",
          "given": "bytes before the 0xAA magic marker arrive in the buffer",
          "when": "feed() scans for the start marker",
          "then": "those pre-marker bytes are discarded and do not corrupt subsequent packet decoding"
        },
        {
          "id": "AC6",
          "given": "tsc --noEmit is run",
          "when": "checking BinaryFrameAccumulator",
          "then": "zero strict-mode errors and no any types are present"
        }
      ],
      "notes": "",
      "dependencies": [
        "US-013"
      ],
      "status": "In Review",
      "created_at": "2026-02-17T20:56:59.543633+00:00",
      "updated_at": "2026-02-17T21:13:00.867794+00:00",
      "created_by": "po",
      "history": [
        {
          "action": "created",
          "by": "po",
          "at": "2026-02-17T20:56:59.543633+00:00"
        },
        {
          "action": "status_change",
          "by": "po",
          "from": "Draft",
          "to": "Ready",
          "at": "2026-02-17T20:58:20.165351+00:00"
        },
        {
          "action": "edited",
          "by": "po",
          "changes": [
            "acceptance_criteria"
          ],
          "at": "2026-02-17T20:59:31.581671+00:00"
        },
        {
          "action": "status_change",
          "by": "dev",
          "from": "Ready",
          "to": "In Progress",
          "at": "2026-02-17T21:10:57.566673+00:00"
        },
        {
          "action": "status_change",
          "by": "dev",
          "from": "In Progress",
          "to": "In Review",
          "at": "2026-02-17T21:13:00.868798+00:00"
        }
      ]
    },
    {
      "id": "US-015",
      "title": "Add binary vs JSON detection in BluetoothContext decodeMessage()",
      "feature_area": "Binary Protocol Support",
      "priority": "Must",
      "role": "developer",
      "want": "decodeMessage() to inspect the first byte of incoming data and route binary packets to the binary decoder path before attempting JSON.parse()",
      "benefit": "binary sEMG packets no longer trigger SyntaxError: JSON Parse error and are correctly handled, while all existing JSON messages continue to work unchanged",
      "acceptance_criteria": [
        {
          "id": "AC1",
          "given": "BluetoothContext.tsx instantiates a BinaryFrameAccumulator",
          "when": "the component mounts",
          "then": "the accumulator is stored as a ref so it persists across re-renders"
        },
        {
          "id": "AC2",
          "given": "decodeMessage() receives data whose first char code is 0xAA",
          "when": "the function executes",
          "then": "the data is converted to Uint8Array via char codes and passed to the accumulator feed() â€” JSON.parse is NOT attempted"
        },
        {
          "id": "AC3",
          "given": "decodeMessage() receives data whose first char code is not 0xAA",
          "when": "the function executes",
          "then": "the existing JSON.parse() path executes unchanged"
        },
        {
          "id": "AC4",
          "given": "a live binary streaming session is running",
          "when": "the device transmits binary packets",
          "then": "no SyntaxError: JSON Parse error appears in the console"
        },
        {
          "id": "AC5",
          "given": "the JSON switch/case for code 13 exists in decodeMessage",
          "when": "binary detection is added",
          "then": "the code-13 JSON case remains intact for backward compatibility with simulation mode"
        },
        {
          "id": "AC6",
          "given": "tsc --noEmit is run on BluetoothContext.tsx",
          "when": "checking new binary path code",
          "then": "zero new type errors are reported"
        }
      ],
      "notes": "",
      "dependencies": [
        "US-014"
      ],
      "status": "In Review",
      "created_at": "2026-02-17T20:57:10.448611+00:00",
      "updated_at": "2026-02-17T21:13:00.998866+00:00",
      "created_by": "po",
      "history": [
        {
          "action": "created",
          "by": "po",
          "at": "2026-02-17T20:57:10.448611+00:00"
        },
        {
          "action": "status_change",
          "by": "po",
          "from": "Draft",
          "to": "Ready",
          "at": "2026-02-17T20:58:20.319910+00:00"
        },
        {
          "action": "edited",
          "by": "po",
          "changes": [
            "acceptance_criteria"
          ],
          "at": "2026-02-17T20:59:31.683152+00:00"
        },
        {
          "action": "status_change",
          "by": "dev",
          "from": "Ready",
          "to": "In Progress",
          "at": "2026-02-17T21:10:57.707952+00:00"
        },
        {
          "action": "status_change",
          "by": "dev",
          "from": "In Progress",
          "to": "In Review",
          "at": "2026-02-17T21:13:00.998866+00:00"
        }
      ]
    },
    {
      "id": "US-016",
      "title": "Integrate decoded binary packets into streamBufferRef pipeline",
      "feature_area": "Binary Protocol Support",
      "priority": "Must",
      "role": "developer",
      "want": "decoded StreamDataPacket objects from the binary path to be pushed into streamBufferRef.current, exactly as the JSON streaming path does",
      "benefit": "the existing flushStreamBuffer() / chart rendering / allStreamPacketsRef / CSV export pipeline receives real sEMG data from the device without any changes to those downstream components",
      "acceptance_criteria": [
        {
          "id": "AC1",
          "given": "the binary decoder path produces StreamDataPacket objects",
          "when": "accumulator.feed() returns decoded packets",
          "then": "each packet is pushed to streamBufferRef.current"
        },
        {
          "id": "AC2",
          "given": "decoded binary packets are in streamBufferRef",
          "when": "flushStreamBuffer() fires after 500 ms",
          "then": "the packets are moved to streamData state and render in the chart component"
        },
        {
          "id": "AC3",
          "given": "decoded binary packets are in streamBufferRef",
          "when": "packets are flushed",
          "then": "they are also appended to allStreamPacketsRef.current for CSV export"
        },
        {
          "id": "AC4",
          "given": "exportStreamData() is called after a binary streaming session",
          "when": "the CSV is generated",
          "then": "it contains rows corresponding to the binary-decoded sEMG samples"
        },
        {
          "id": "AC5",
          "given": "the downstream pipeline (flushStreamBuffer, chart, exportStreamData) is inspected",
          "when": "verifying changes required",
          "then": "no modifications are needed to those components"
        }
      ],
      "notes": "",
      "dependencies": [
        "US-015"
      ],
      "status": "In Review",
      "created_at": "2026-02-17T20:57:21.799522+00:00",
      "updated_at": "2026-02-17T21:13:01.150768+00:00",
      "created_by": "po",
      "history": [
        {
          "action": "created",
          "by": "po",
          "at": "2026-02-17T20:57:21.799522+00:00"
        },
        {
          "action": "status_change",
          "by": "po",
          "from": "Draft",
          "to": "Ready",
          "at": "2026-02-17T20:58:20.447123+00:00"
        },
        {
          "action": "edited",
          "by": "po",
          "changes": [
            "acceptance_criteria"
          ],
          "at": "2026-02-17T20:59:31.785379+00:00"
        },
        {
          "action": "status_change",
          "by": "dev",
          "from": "Ready",
          "to": "In Progress",
          "at": "2026-02-17T21:10:57.839907+00:00"
        },
        {
          "action": "status_change",
          "by": "dev",
          "from": "In Progress",
          "to": "In Review",
          "at": "2026-02-17T21:13:01.150768+00:00"
        }
      ]
    },
    {
      "id": "US-017",
      "title": "Add binary packet validation, error logging, and dropped-packet counter",
      "feature_area": "Binary Protocol Support",
      "priority": "Must",
      "role": "developer",
      "want": "invalid binary packets to be logged with a console.warn and counted, rather than silently discarded",
      "benefit": "debugging a misbehaving device or encoding issue is straightforward",
      "acceptance_criteria": [
        {
          "id": "AC1",
          "given": "decodeBinaryPacket receives a buffer with an invalid magic byte after framing",
          "when": "the function executes",
          "then": "it returns null"
        },
        {
          "id": "AC2",
          "given": "BluetoothContext processes a dropped binary packet",
          "when": "the drop occurs",
          "then": "binaryPacketsDropped counter (ref) is incremented and console.warn is called with a descriptive reason"
        },
        {
          "id": "AC3",
          "given": "BluetoothContext successfully decodes a binary packet",
          "when": "the packet is decoded",
          "then": "binaryPacketsReceived counter (ref) is incremented"
        },
        {
          "id": "AC4",
          "given": "JSON.parse() fails on data that does not start with 0xAA",
          "when": "the error occurs",
          "then": "console.warn is called (existing behavior) and the app does not crash"
        },
        {
          "id": "AC5",
          "given": "any binary framing or validation error occurs",
          "when": "the error is caught",
          "then": "the app continues running and subsequent Bluetooth data is processed normally"
        }
      ],
      "notes": "",
      "dependencies": [
        "US-015"
      ],
      "status": "In Review",
      "created_at": "2026-02-17T20:57:56.618636+00:00",
      "updated_at": "2026-02-17T21:13:01.279723+00:00",
      "created_by": "po",
      "history": [
        {
          "action": "created",
          "by": "po",
          "at": "2026-02-17T20:57:56.618636+00:00"
        },
        {
          "action": "status_change",
          "by": "po",
          "from": "Draft",
          "to": "Ready",
          "at": "2026-02-17T20:58:20.578271+00:00"
        },
        {
          "action": "edited",
          "by": "po",
          "changes": [
            "acceptance_criteria"
          ],
          "at": "2026-02-17T20:59:31.884459+00:00"
        },
        {
          "action": "status_change",
          "by": "dev",
          "from": "Ready",
          "to": "In Progress",
          "at": "2026-02-17T21:10:58.033421+00:00"
        },
        {
          "action": "status_change",
          "by": "dev",
          "from": "In Progress",
          "to": "In Review",
          "at": "2026-02-17T21:13:01.279723+00:00"
        }
      ]
    },
    {
      "id": "US-018",
      "title": "Ensure TypeScript strict mode compliance for all binary decoder code",
      "feature_area": "Binary Protocol Support",
      "priority": "Must",
      "role": "developer",
      "want": "all new binary decoding code to have explicit types and pass strict TypeScript compilation with zero errors",
      "benefit": "the codebase maintains its strict-mode contract and future contributors cannot introduce runtime type errors in the binary path",
      "acceptance_criteria": [
        {
          "id": "AC1",
          "given": "tsc --noEmit is run on apps/mobile after all binary decoder code is added",
          "when": "checking binaryDecoder.ts",
          "then": "zero strict-mode errors are reported and no any types exist"
        },
        {
          "id": "AC2",
          "given": "tsc --noEmit is run on apps/mobile after BluetoothContext.tsx is modified",
          "when": "checking the new binary path code",
          "then": "zero new type errors are introduced compared to the baseline"
        },
        {
          "id": "AC3",
          "given": "decodeBinaryPacket is inspected for its return type annotation",
          "when": "checking the function signature",
          "then": "the return type is explicitly declared as { packet: StreamDataPacket; bytesConsumed: number } | null"
        },
        {
          "id": "AC4",
          "given": "BinaryFrameAccumulator.feed() is inspected",
          "when": "checking parameter and return types",
          "then": "the parameter is typed as Uint8Array and the return is typed as StreamDataPacket[]"
        },
        {
          "id": "AC5",
          "given": "the string-to-Uint8Array conversion helper in BluetoothContext is inspected",
          "when": "checking for implicit any",
          "then": "all variables and function signatures have explicit types"
        }
      ],
      "notes": "",
      "dependencies": [
        "US-013",
        "US-014",
        "US-015"
      ],
      "status": "In Review",
      "created_at": "2026-02-17T20:58:13.161944+00:00",
      "updated_at": "2026-02-17T21:13:01.414181+00:00",
      "created_by": "po",
      "history": [
        {
          "action": "created",
          "by": "po",
          "at": "2026-02-17T20:58:13.161944+00:00"
        },
        {
          "action": "status_change",
          "by": "po",
          "from": "Draft",
          "to": "Ready",
          "at": "2026-02-17T20:58:20.711682+00:00"
        },
        {
          "action": "edited",
          "by": "po",
          "changes": [
            "acceptance_criteria"
          ],
          "at": "2026-02-17T20:59:31.987625+00:00"
        },
        {
          "action": "status_change",
          "by": "dev",
          "from": "Ready",
          "to": "In Progress",
          "at": "2026-02-17T21:10:58.168123+00:00"
        },
        {
          "action": "status_change",
          "by": "dev",
          "from": "In Progress",
          "to": "In Review",
          "at": "2026-02-17T21:13:01.414181+00:00"
        }
      ]
    },
    {
      "id": "US-019",
      "title": "Validate isStreaming flag behavior with binary protocol device",
      "feature_area": "Stream Bug: H1 Investigation",
      "priority": "Must",
      "role": "developer",
      "want": "to confirm whether the isStreaming flag in BluetoothContext transitions to true when connected to a binary-protocol device",
      "benefit": "we can confirm or rule out H1 as the root cause of the empty CSV and static chart bug",
      "acceptance_criteria": [
        "Add console.log inside the isStreaming useEffect (BluetoothContext.tsx lines 124-147) that logs the transition when isStreaming changes to true",
        "Add console.log inside startStream() (line 538) that logs immediately after the BT command is sent",
        "Add console.log inside the JSON ACK handler for StartStream (lines 433-437) that logs when the ACK is received and parsed",
        "Run a real device recording session and capture the logs â€” document whether isStreaming transitions to true",
        "If isStreaming never transitions to true with a binary device, confirm that streamBufferRef accumulates packets (log its length inside decodeMessage after each push)",
        "Document findings: which log appeared, which did not, and at what timestamps"
      ],
      "notes": "",
      "dependencies": [],
      "status": "Done",
      "created_at": "2026-02-17T21:52:20.119085+00:00",
      "updated_at": "2026-02-17T21:54:31.323986+00:00",
      "created_by": "po",
      "history": [
        {
          "action": "created",
          "by": "po",
          "at": "2026-02-17T21:52:20.119085+00:00"
        },
        {
          "action": "status_change",
          "by": "po",
          "from": "Draft",
          "to": "Ready",
          "at": "2026-02-17T21:54:31.323986+00:00"
        }
      ]
    },
    {
      "id": "US-020",
      "title": "Validate race condition between stopStream and getAllStreamPackets",
      "feature_area": "Stream Bug: H2 Investigation",
      "priority": "Must",
      "role": "developer",
      "want": "to confirm whether getAllStreamPackets is called before the final flushStreamBuffer completes after stopping the stream",
      "benefit": "we can confirm or rule out H2 as a contributing cause of missing CSV data, independently of H1",
      "acceptance_criteria": [
        "Add console.log at the start of handleStopRecording (CaptureScreen.tsx line 186) that logs streamBufferRef.current.length and allStreamPacketsRef.current.length before stopStream() is awaited",
        "Add console.log at the end of flushStreamBuffer() that logs how many packets were moved to allStreamPacketsRef",
        "Add console.log at the start of getAllStreamPackets() (BluetoothContext.tsx line 682) that logs allStreamPacketsRef.current.length before and after the internal flushStreamBuffer call",
        "Run a real device recording session: start recording, record for 10+ seconds, stop recording, and capture the log sequence",
        "Document the exact order of log lines and timestamps â€” confirm whether getAllStreamPackets sees data that flushStreamBuffer placed during stopStream cleanup",
        "If a race condition is confirmed, document the precise timing gap between the last flush and getAllStreamPackets execution"
      ],
      "notes": "",
      "dependencies": [],
      "status": "Done",
      "created_at": "2026-02-17T21:52:35.363893+00:00",
      "updated_at": "2026-02-17T21:54:31.450142+00:00",
      "created_by": "po",
      "history": [
        {
          "action": "created",
          "by": "po",
          "at": "2026-02-17T21:52:35.363893+00:00"
        },
        {
          "action": "status_change",
          "by": "po",
          "from": "Draft",
          "to": "Ready",
          "at": "2026-02-17T21:54:31.450142+00:00"
        }
      ]
    },
    {
      "id": "US-021",
      "title": "Fix: start batch flush interval independently of JSON ACK for binary protocol",
      "feature_area": "Stream Bug: H1 Fix",
      "priority": "Must",
      "role": "developer",
      "want": "the 500ms batch flush interval to start when the first binary packet arrives, not only when a JSON ACK for StartStream is received",
      "benefit": "stream data flows to allStreamPacketsRef and streamData state during real device recording sessions, so both chart and CSV export receive data",
      "acceptance_criteria": [
        "The batch flush interval (BluetoothContext.tsx lines 124-147) starts as soon as the first binary stream packet is received, without requiring a JSON ACK",
        "Alternatively, isStreaming is set to true when the first binary packet (0xAA magic byte) is received and routed to BinaryFrameAccumulator â€” not gated on JSON ACK parsing",
        "The fix does not break the existing JSON ACK path: if a JSON ACK arrives for StartStream, it still sets isStreaming to true (no regression for JSON protocol devices)",
        "Simulation mode is unaffected: the simulation data path does not use isStreaming or streamBufferRef",
        "After the fix, a real device recording session populates streamData with packets during recording",
        "After the fix, allStreamPacketsRef contains all accumulated packets when getAllStreamPackets is called on stop",
        "The fix is a minimal code change â€” no refactoring of unrelated logic"
      ],
      "notes": "",
      "dependencies": [
        "US-019"
      ],
      "status": "Done",
      "created_at": "2026-02-17T21:52:46.844086+00:00",
      "updated_at": "2026-02-17T21:54:31.572394+00:00",
      "created_by": "po",
      "history": [
        {
          "action": "created",
          "by": "po",
          "at": "2026-02-17T21:52:46.844086+00:00"
        },
        {
          "action": "status_change",
          "by": "po",
          "from": "Draft",
          "to": "Ready",
          "at": "2026-02-17T21:54:31.572394+00:00"
        }
      ]
    },
    {
      "id": "US-022",
      "title": "Fix: synchronize stopStream with final buffer flush before CSV export",
      "feature_area": "Stream Bug: H2 Fix",
      "priority": "Must",
      "role": "developer",
      "want": "all stream data in streamBufferRef to be flushed to allStreamPacketsRef before getAllStreamPackets returns after recording stops",
      "benefit": "the CSV export captures every recorded packet, including those that arrived between the last periodic flush and the stop command",
      "acceptance_criteria": [
        "getAllStreamPackets() guarantees that flushStreamBuffer() has completed before returning the packet array",
        "Any packets still in streamBufferRef at the time stopStream is called are included in the returned packet array",
        "The fix handles the case where the BT StopStream ACK is async â€” data arriving between stop command send and ACK receipt is not lost",
        "The fix does not introduce a deadlock or indefinite await",
        "After the fix, a real device recording session produces a CSV with all samples from start to stop",
        "Simulation mode CSV export is unaffected"
      ],
      "notes": "",
      "dependencies": [
        "US-020"
      ],
      "status": "Done",
      "created_at": "2026-02-17T21:53:10.188416+00:00",
      "updated_at": "2026-02-17T21:54:31.729316+00:00",
      "created_by": "po",
      "history": [
        {
          "action": "created",
          "by": "po",
          "at": "2026-02-17T21:53:10.188416+00:00"
        },
        {
          "action": "status_change",
          "by": "po",
          "from": "Draft",
          "to": "Ready",
          "at": "2026-02-17T21:54:31.729316+00:00"
        }
      ]
    },
    {
      "id": "US-023",
      "title": "Fix: improve chart update cadence to reflect real-time data during recording",
      "feature_area": "Stream Bug: Chart Fix",
      "priority": "Should",
      "role": "researcher",
      "want": "the waveform chart on CaptureScreen to update visibly during a real device recording session",
      "benefit": "I can confirm the device is transmitting valid sEMG data in real time and identify signal quality issues during the session",
      "acceptance_criteria": [
        "The SEMGChart updates at least once per second during a real device recording session when stream data is flowing",
        "The chart displays the most recent 4 seconds of sEMG data at 40 Hz (as per CHART_DISPLAY_RATE_HZ and CHART_WINDOW_SECONDS domain constants)",
        "If the useStreamData hook 1 Hz cadence is confirmed as the cause of perceived staleness, the cadence is reviewed and updated to a value that feels responsive to the researcher",
        "Chart updates do not cause visible jank or performance degradation on a mid-range Android device",
        "Simulation mode chart behavior is unaffected"
      ],
      "notes": "",
      "dependencies": [
        "US-021"
      ],
      "status": "Done",
      "created_at": "2026-02-17T21:53:25.893686+00:00",
      "updated_at": "2026-02-17T21:54:31.861022+00:00",
      "created_by": "po",
      "history": [
        {
          "action": "created",
          "by": "po",
          "at": "2026-02-17T21:53:25.893686+00:00"
        },
        {
          "action": "status_change",
          "by": "po",
          "from": "Draft",
          "to": "Ready",
          "at": "2026-02-17T21:54:31.861022+00:00"
        }
      ]
    },
    {
      "id": "US-024",
      "title": "Add diagnostic instrumentation at 3 key pipeline points",
      "feature_area": "Stream Bug: Instrumentation",
      "priority": "Should",
      "role": "developer",
      "want": "persistent diagnostic logging at BinaryFrameAccumulator output, allStreamPacketsRef before CSV write, and streamBufferRef at flush time",
      "benefit": "future debugging of stream pipeline issues requires no code changes â€” the data is already visible in the dev console",
      "acceptance_criteria": [
        "BinaryFrameAccumulator.getStats() is logged at stream stop time: shows received packet count, dropped packet count, and last error if any",
        "allStreamPacketsRef.current.length is logged immediately before createCSVContent is called in handleStopRecording",
        "streamBufferRef.current.length is logged at the start and end of every flushStreamBuffer() call",
        "All diagnostic logs use a consistent prefix (e.g., [StreamPipeline]) to allow easy filtering",
        "Diagnostic logs are dev-only â€” they do not appear in production builds (use __DEV__ guard or equivalent)",
        "No business logic is changed â€” purely additive logging"
      ],
      "notes": "",
      "dependencies": [],
      "status": "Ready",
      "created_at": "2026-02-17T21:53:41.761217+00:00",
      "updated_at": "2026-02-17T21:54:31.985875+00:00",
      "created_by": "po",
      "history": [
        {
          "action": "created",
          "by": "po",
          "at": "2026-02-17T21:53:41.761217+00:00"
        },
        {
          "action": "status_change",
          "by": "po",
          "from": "Draft",
          "to": "Ready",
          "at": "2026-02-17T21:54:31.985875+00:00"
        }
      ]
    },
    {
      "id": "US-025",
      "title": "Unit tests for createCSVContent, BinaryFrameAccumulator, and flushStreamBuffer",
      "feature_area": "Stream Bug: Testing",
      "priority": "Must",
      "role": "developer",
      "want": "automated unit tests for the three most critical functions in the stream data pipeline",
      "benefit": "regressions in the binary decoder, CSV generation, or flush logic are caught automatically before they reach a real device recording session",
      "acceptance_criteria": [
        "createCSVContent: test with 0 packets (output is header-only), 1 packet, and N packets â€” verify row count and timestamp/value format",
        "createCSVContent: test with packets containing multiple samples â€” verify each sample produces exactly one CSV row",
        "BinaryFrameAccumulator: test feed() with a complete valid 108-byte packet â€” verify one packet is emitted with correct sample values",
        "BinaryFrameAccumulator: test feed() with a partial packet split across two calls â€” verify packet is assembled and emitted on second call",
        "BinaryFrameAccumulator: test feed() with wrong magic byte â€” verify packet is dropped and getStats().dropped increments",
        "flushStreamBuffer: test that calling flush with N packets in streamBufferRef moves all N to allStreamPacketsRef and clears streamBufferRef",
        "flushStreamBuffer: test that calling flush with 0 packets is a no-op (no error, no state change)",
        "All tests pass with npm test or the project test runner"
      ],
      "notes": "",
      "dependencies": [
        "US-021 US-022"
      ],
      "status": "Done",
      "created_at": "2026-02-17T21:53:57.359874+00:00",
      "updated_at": "2026-02-17T21:54:32.112864+00:00",
      "created_by": "po",
      "history": [
        {
          "action": "created",
          "by": "po",
          "at": "2026-02-17T21:53:57.359874+00:00"
        },
        {
          "action": "status_change",
          "by": "po",
          "from": "Draft",
          "to": "Ready",
          "at": "2026-02-17T21:54:32.112864+00:00"
        }
      ]
    },
    {
      "id": "US-026",
      "title": "Integration test for full Bluetooth to CSV pipeline",
      "feature_area": "Stream Bug: Testing",
      "priority": "Should",
      "role": "developer",
      "want": "an integration test that simulates the full BTâ†’decodeâ†’bufferâ†’flushâ†’CSV pipeline without a real device",
      "benefit": "the complete data path from binary Bluetooth packet to CSV content can be verified in CI without requiring physical hardware",
      "acceptance_criteria": [
        "Test simulates receiving N binary BT packets (valid 108-byte frames) via a mocked onDataReceived callback",
        "Test triggers the batch flush (or calls flushStreamBuffer directly) after packets are fed",
        "Test calls getAllStreamPackets() and verifies the returned array length matches the number of simulated packets times samples-per-packet (50)",
        "Test calls createCSVContent with the returned packets and verifies the CSV has the correct number of rows (N * 50 + 1 header)",
        "Test covers the stop scenario: packets arrive, stopStream is called, getAllStreamPackets is called â€” data is not lost",
        "Test runs in the mobile app test environment (Jest + React Native Testing Library or equivalent)"
      ],
      "notes": "",
      "dependencies": [
        "US-025"
      ],
      "status": "Ready",
      "created_at": "2026-02-17T21:54:16.714849+00:00",
      "updated_at": "2026-02-17T21:54:32.241283+00:00",
      "created_by": "po",
      "history": [
        {
          "action": "created",
          "by": "po",
          "at": "2026-02-17T21:54:16.714849+00:00"
        },
        {
          "action": "status_change",
          "by": "po",
          "from": "Draft",
          "to": "Ready",
          "at": "2026-02-17T21:54:32.241283+00:00"
        }
      ]
    },
    {
      "id": "US-027",
      "title": "Recording lifecycle API in BluetoothContext",
      "feature_area": "Incremental CSV Recording",
      "priority": "Must",
      "role": "developer integrating CSV recording",
      "want": "BluetoothContext to expose startRecording(sessionId), stopRecording(), and isRecording so the recording lifecycle can be managed from any screen",
      "benefit": "recording state is managed centrally with proper ref-based access from the stale BT listener closure, avoiding race conditions",
      "acceptance_criteria": [
        {
          "id": "AC1",
          "given": "startRecording(sessionId) is called",
          "when": "no recording is active",
          "then": "a CSV file is created at DocumentDirectory/{sessionId}.csv with header row timestamp,value, recordingFilePathRef and isRecordingRef are set, sampleCountRef is reset to 0, and the file path is returned"
        },
        {
          "id": "AC2",
          "given": "stopRecording() is called",
          "when": "a recording is active",
          "then": "isRecordingRef and recordingFilePathRef are cleared, and the function returns { filePath, sampleCount } with the total samples written"
        },
        {
          "id": "AC3",
          "given": "the BluetoothContext is inspected",
          "when": "a recording is active",
          "then": "isRecording boolean state is true and is accessible via the context interface"
        },
        {
          "id": "AC4",
          "given": "the BluetoothContextData interface is compiled",
          "when": "TypeScript strict mode is enabled",
          "then": "startRecording, stopRecording, and isRecording entries are present with correct types and no any"
        },
        {
          "id": "AC5",
          "given": "startRecording() is called",
          "when": "a recording is already active (stale file handle)",
          "then": "the existing recording is closed before a new one is created"
        },
        {
          "id": "AC6",
          "given": "all three refs are declared",
          "when": "TypeScript compiles the file",
          "then": "each ref is typed as React.MutableRefObject<string|null>, React.MutableRefObject<boolean>, and React.MutableRefObject<number> respectively with no any"
        }
      ],
      "notes": "",
      "dependencies": [],
      "status": "Done",
      "created_at": "2026-02-17T22:26:25.967669+00:00",
      "updated_at": "2026-02-18T01:10:54.248857+00:00",
      "created_by": "po",
      "history": [
        {
          "action": "created",
          "by": "po",
          "at": "2026-02-17T22:26:25.967669+00:00"
        },
        {
          "action": "status_change",
          "by": "po",
          "from": "Draft",
          "to": "Ready",
          "at": "2026-02-17T22:27:30.916804+00:00"
        },
        {
          "action": "edited",
          "by": "po",
          "changes": [
            "acceptance_criteria"
          ],
          "at": "2026-02-17T22:28:27.405954+00:00"
        },
        {
          "action": "status_change",
          "by": "tl",
          "from": "Ready",
          "to": "Done",
          "at": "2026-02-18T01:10:54.248857+00:00"
        }
      ]
    },
    {
      "id": "US-028",
      "title": "Per-packet CSV append at full 215 Hz",
      "feature_area": "Incremental CSV Recording",
      "priority": "Must",
      "role": "researcher conducting a sEMG session",
      "want": "all 50 samples from each Bluetooth binary packet to be written to disk immediately when the packet arrives",
      "benefit": "the CSV file contains the complete 215 Hz dataset regardless of session length or app lifecycle events, with no data held in RAM",
      "acceptance_criteria": [
        {
          "id": "AC1",
          "given": "a binary BT packet is decoded and isRecordingRef is true",
          "when": "the decode path executes",
          "then": "all 50 samples are appended to the CSV file at recordingFilePathRef before any downsample step"
        },
        {
          "id": "AC2",
          "given": "a packet with timestamp T and 50 values is appended",
          "when": "the CSV lines are written",
          "then": "each line is formatted as T+(i*(1000/215)).toFixed(2),value for i in 0..49, producing exactly 50 lines"
        },
        {
          "id": "AC3",
          "given": "an append completes successfully",
          "when": "sampleCountRef is updated",
          "then": "sampleCountRef is incremented by 50"
        },
        {
          "id": "AC4",
          "given": "the file system throws an error during append",
          "when": "the error is caught",
          "then": "the error is logged but the BT listener continues without crashing and streaming is not stopped"
        },
        {
          "id": "AC5",
          "given": "a simulated 10-second recording at 215 Hz completes",
          "when": "the CSV file is opened",
          "then": "it contains exactly 1 header row plus 2150 data rows"
        },
        {
          "id": "AC6",
          "given": "the CSV output is compared to createCSVContent()",
          "when": "formatting is checked",
          "then": "the incremental output is byte-for-byte identical for the same set of packets"
        }
      ],
      "notes": "",
      "dependencies": [
        "US-027"
      ],
      "status": "Done",
      "created_at": "2026-02-17T22:26:40.090771+00:00",
      "updated_at": "2026-02-18T01:10:54.248857+00:00",
      "created_by": "po",
      "history": [
        {
          "action": "created",
          "by": "po",
          "at": "2026-02-17T22:26:40.091777+00:00"
        },
        {
          "action": "status_change",
          "by": "po",
          "from": "Draft",
          "to": "Ready",
          "at": "2026-02-17T22:27:31.055545+00:00"
        },
        {
          "action": "edited",
          "by": "po",
          "changes": [
            "acceptance_criteria"
          ],
          "at": "2026-02-17T22:28:38.401709+00:00"
        },
        {
          "action": "status_change",
          "by": "tl",
          "from": "Ready",
          "to": "Done",
          "at": "2026-02-18T01:10:54.248857+00:00"
        }
      ]
    },
    {
      "id": "US-029",
      "title": "Per-packet 50-to-10 downsample before chart pipeline",
      "feature_area": "Incremental CSV Recording",
      "priority": "Must",
      "role": "developer optimizing chart rendering",
      "want": "each 50-sample binary packet to be downsampled to 10 samples (every 5th sample) before being pushed into streamBufferRef",
      "benefit": "the data volume flowing through React state and the chart pipeline is reduced by 80%, lowering memory pressure and render overhead while maintaining adequate chart resolution (~43 Hz effective rate)",
      "acceptance_criteria": [
        {
          "id": "AC1",
          "given": "a 50-sample packet is decoded and CSV append completes",
          "when": "the downsample step runs",
          "then": "a new StreamDataPacket is created with 10 values taken at indices 0, 5, 10, 15, 20, 25, 30, 35, 40, 45 of the original array"
        },
        {
          "id": "AC2",
          "given": "the downsampled packet is created",
          "when": "it is pushed into streamBufferRef",
          "then": "only the 10-sample packet is pushed — the original 50-sample packet is not pushed"
        },
        {
          "id": "AC3",
          "given": "simulation mode is active (no device)",
          "when": "simulated data flows through the pipeline",
          "then": "the BT decode path is not exercised and simulation behavior is unchanged"
        },
        {
          "id": "AC4",
          "given": "useStreamData receives the downsampled packets",
          "when": "it renders the 4-second sliding window",
          "then": "the chart displays correctly without any changes to the hook"
        },
        {
          "id": "AC5",
          "given": "the downsampled packet type is checked",
          "when": "TypeScript strict mode compiles",
          "then": "the packet conforms to StreamDataPacket from @iris/domain with no any types"
        }
      ],
      "notes": "",
      "dependencies": [
        "US-028"
      ],
      "status": "Done",
      "created_at": "2026-02-17T22:26:52.158908+00:00",
      "updated_at": "2026-02-18T01:10:54.248857+00:00",
      "created_by": "po",
      "history": [
        {
          "action": "created",
          "by": "po",
          "at": "2026-02-17T22:26:52.158908+00:00"
        },
        {
          "action": "status_change",
          "by": "po",
          "from": "Draft",
          "to": "Ready",
          "at": "2026-02-17T22:27:31.185038+00:00"
        },
        {
          "action": "edited",
          "by": "po",
          "changes": [
            "acceptance_criteria"
          ],
          "at": "2026-02-17T22:28:51.740116+00:00"
        },
        {
          "action": "status_change",
          "by": "tl",
          "from": "Ready",
          "to": "Done",
          "at": "2026-02-18T01:10:54.248857+00:00"
        }
      ]
    },
    {
      "id": "US-030",
      "title": "CaptureScreen: use recording lifecycle API instead of bulk CSV",
      "feature_area": "Incremental CSV Recording",
      "priority": "Must",
      "role": "researcher who presses Stop to end a session",
      "want": "CaptureScreen to call startRecording on session start and stopRecording on session stop, receiving the file path and sample count without any in-memory bulk serialization",
      "benefit": "the stop action is fast and deterministic regardless of recording duration, and the recording entity is created with accurate metadata from incremental writes",
      "acceptance_criteria": [
        {
          "id": "AC1",
          "given": "CaptureScreen mounts and a session is initiated",
          "when": "recording begins",
          "then": "startRecording(sessionId) is called and awaited, and the returned file path is stored for later use"
        },
        {
          "id": "AC2",
          "given": "the user presses Stop",
          "when": "the stop handler executes",
          "then": "stopRecording() is awaited and { filePath, sampleCount } is used to populate the NewRecordingData entity"
        },
        {
          "id": "AC3",
          "given": "the NewRecordingData entity is created",
          "when": "fields are inspected",
          "then": "filePath and sampleCount come from stopRecording(), sampleRate equals DEVICE_SAMPLE_RATE_HZ (215), and durationSeconds is computed from elapsed wall-clock time"
        },
        {
          "id": "AC4",
          "given": "CaptureScreen source is reviewed",
          "when": "searching for createCSVContent()",
          "then": "the function is absent — bulk CSV serialization is removed"
        },
        {
          "id": "AC5",
          "given": "CaptureScreen source is reviewed",
          "when": "searching for getAllStreamPackets()",
          "then": "the call is absent from the stop handler"
        },
        {
          "id": "AC6",
          "given": "a full session completes (start → stop)",
          "when": "the recordings list is opened",
          "then": "the new recording is visible with correct metadata and no regression in the happy path"
        }
      ],
      "notes": "",
      "dependencies": [
        "US-027"
      ],
      "status": "Done",
      "created_at": "2026-02-17T22:27:03.848949+00:00",
      "updated_at": "2026-02-18T01:10:54.248857+00:00",
      "created_by": "po",
      "history": [
        {
          "action": "created",
          "by": "po",
          "at": "2026-02-17T22:27:03.848949+00:00"
        },
        {
          "action": "status_change",
          "by": "po",
          "from": "Draft",
          "to": "Ready",
          "at": "2026-02-17T22:27:31.316939+00:00"
        },
        {
          "action": "edited",
          "by": "po",
          "changes": [
            "acceptance_criteria"
          ],
          "at": "2026-02-17T22:29:03.679886+00:00"
        },
        {
          "action": "status_change",
          "by": "tl",
          "from": "Ready",
          "to": "Done",
          "at": "2026-02-18T01:10:54.248857+00:00"
        }
      ]
    },
    {
      "id": "US-031",
      "title": "Cleanup: remove allStreamPacketsRef and deprecated bulk CSV functions",
      "feature_area": "Incremental CSV Recording",
      "priority": "Must",
      "role": "developer maintaining BluetoothContext",
      "want": "allStreamPacketsRef, getAllStreamPackets(), and the bulk createCSVContent() function to be removed from BluetoothContext after incremental recording is in place",
      "benefit": "the codebase is free of the unbounded in-memory packet accumulator that was the sole driver of CSV export, reducing RAM usage during long recordings",
      "acceptance_criteria": [
        {
          "id": "AC1",
          "given": "BluetoothContext source is reviewed",
          "when": "searching for allStreamPacketsRef",
          "then": "the ref declaration is absent"
        },
        {
          "id": "AC2",
          "given": "the BluetoothContextData interface is inspected",
          "when": "searching for getAllStreamPackets",
          "then": "the method is absent from the interface and its implementation"
        },
        {
          "id": "AC3",
          "given": "the codebase is searched with grep",
          "when": "looking for getAllStreamPackets() or createCSVContent() calls",
          "then": "no remaining callers are found in any file"
        },
        {
          "id": "AC4",
          "given": "the flushStreamBuffer interval runs",
          "when": "it executes after cleanup",
          "then": "it no longer references allStreamPacketsRef and continues to function correctly"
        },
        {
          "id": "AC5",
          "given": "the TypeScript compiler runs after removal",
          "when": "all files are compiled",
          "then": "no type errors are produced"
        }
      ],
      "notes": "",
      "dependencies": [
        "US-028",
        "US-030"
      ],
      "status": "Done",
      "created_at": "2026-02-17T22:27:13.679060+00:00",
      "updated_at": "2026-02-18T01:10:54.248857+00:00",
      "created_by": "po",
      "history": [
        {
          "action": "created",
          "by": "po",
          "at": "2026-02-17T22:27:13.679060+00:00"
        },
        {
          "action": "status_change",
          "by": "po",
          "from": "Draft",
          "to": "Ready",
          "at": "2026-02-17T22:27:31.445567+00:00"
        },
        {
          "action": "edited",
          "by": "po",
          "changes": [
            "acceptance_criteria"
          ],
          "at": "2026-02-17T22:29:11.835778+00:00"
        },
        {
          "action": "status_change",
          "by": "tl",
          "from": "Ready",
          "to": "Done",
          "at": "2026-02-18T01:10:54.248857+00:00"
        }
      ]
    },
    {
      "id": "US-032",
      "title": "Tests: downsample logic, CSV append format, recording lifecycle",
      "feature_area": "Incremental CSV Recording",
      "priority": "Should",
      "role": "developer validating the incremental recording implementation",
      "want": "unit tests that verify the downsample function, the CSV append format, and the recording lifecycle state transitions",
      "benefit": "regressions in the 215 Hz CSV output or the chart downsample ratio are caught automatically before shipping",
      "acceptance_criteria": [
        {
          "id": "AC1",
          "given": "the downsample function receives a 50-element array",
          "when": "it runs",
          "then": "it returns exactly 10 elements at indices 0, 5, 10, 15, 20, 25, 30, 35, 40, 45"
        },
        {
          "id": "AC2",
          "given": "a packet with timestamp T and 50 values is processed",
          "when": "CSV line generation runs",
          "then": "the output contains 50 lines formatted as (T + i*(1000/215)).toFixed(2),value for i in 0..49"
        },
        {
          "id": "AC3",
          "given": "startRecording() is called",
          "when": "the lifecycle state is inspected",
          "then": "isRecordingRef is true and recordingFilePathRef is non-null"
        },
        {
          "id": "AC4",
          "given": "stopRecording() is called after N appends of 50 samples each",
          "when": "the result is inspected",
          "then": "both refs are cleared and sampleCount equals N * 50"
        },
        {
          "id": "AC5",
          "given": "all tests are run with the project test runner",
          "when": "the suite completes",
          "then": "all new tests pass and no existing tests regress"
        }
      ],
      "notes": "",
      "dependencies": [
        "US-027",
        "US-028",
        "US-029",
        "US-030",
        "US-031"
      ],
      "status": "Done",
      "created_at": "2026-02-17T22:27:25.171589+00:00",
      "updated_at": "2026-02-18T01:10:54.248857+00:00",
      "created_by": "po",
      "history": [
        {
          "action": "created",
          "by": "po",
          "at": "2026-02-17T22:27:25.171589+00:00"
        },
        {
          "action": "status_change",
          "by": "po",
          "from": "Draft",
          "to": "Ready",
          "at": "2026-02-17T22:27:31.573724+00:00"
        },
        {
          "action": "edited",
          "by": "po",
          "changes": [
            "acceptance_criteria"
          ],
          "at": "2026-02-17T22:29:21.579596+00:00"
        },
        {
          "action": "status_change",
          "by": "tl",
          "from": "Ready",
          "to": "Done",
          "at": "2026-02-18T01:10:54.248857+00:00"
        }
      ]
    }
  ],
  "questions": []
}